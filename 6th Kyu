#If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
#Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Additionally, if the number is negative, return 0 (for languages that do have them).
def solution(number) :
    arr = []
    result = []
    for i in range(0,number) :
        arr.append(i)
    for i in arr :
        if i % 3 == 0 :
            result.append(i)
        elif i % 5 == 0 :
            result.append(i)
        elif i < 0 :
            result
    return sum(set(result))        
    


#You probably know the "like" system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.
def likes(names) :
    result = ""
    if len(names) == 1 :
        result += names[0] + " likes this"
    elif len(names) ==2 :
        result +=  names[0] + " and " + names[1] + " like this"
    elif len(names) == 3 :
        result += names[0] +", " + names[1] + " and " + names[2] + " like this"
    elif len(names) >= 4 :
        result +=  names[0] + ", " + names[1] + " and " + str(len(names)-2) + " others like this"
    else :
        result += "no one like this"   
    return result

            
#Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

def create_phone_number(n):
    return "(%s%s%s) %s%s%s-%s%s%s%s" % (n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9])
    


#Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.

def count_bits(n):
    result = bin(int(n))
    return result.count("1")
    

#You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer 
def find_outlier(integers):
    even = []
    odd = []
    for i in integers :
        if i % 2 == 0 :
            even.append(i)
        else :
            odd.append(i)
    if len(even) > len(odd) :
        return odd[0] #remember we can use indexing to return 
    elif len(odd) > len(even) :
        return even[0]
    

Given an array of integers, find the one that appears an odd number of times.
def find_it(seq):
    result = []
    for i in seq :
        if seq.count(i) % 2 != 0 :
            result.append(i)
    return result[0]      



#Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string

def duplicate_count(text):
    result = []
    text = text.lower() #makes it case insensitive
    for i in text :
        if text.count(i) > 1 :
            result.append(i)
    return len(set(result))


def narcissistic( value ):
    result = []
    string_value = str(value)
    no_of_digits = len(str(value))
    arr_of_integers = [int(i) for i in string_value] #how to split a string into a list of integers
    for i in arr_of_integers :
        result.append(i**no_of_digits)
    if sum(result) == value :
        return True
    else :
        return False


##There is an array with some numbers. All numbers are equal except for one. Try to find it!

def find_uniq(arr):
    result = []
    for i in arr :
        if arr.count(i) == 1 :
            result.append(i)
    return result[0] 
     
#Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.It should remove all values from list a, which are present in list b keeping their order.
def array_diff(a, b):
    result = []
    for i in a :
        if i not in b :
            result.append(i)
    return result    



def parts_sums(ls):
    result = []
    for i in range(len(ls)) :
        result.append(ls[i:])
    result.append([])
    return list(map(sum,result))


#For example, encode("hello") would return "h2ll4". There is no need to worry about uppercase vowels in this kata.
def encode(st):
    dict = {"a":"1","e":"2","i":"3","o":"4","u":"5"}
    vowels = "aeiou"
    result = ""
    new_st = [str(i) for i in st]
    for i in new_st :
        if i == i.lower() and i in vowels :
            result += dict[i]
        else :
            result += i
    return result       

def decode(st) :
    dict = {"1":"a","2":"e","3":"i","4":"o","5":"u"}
    numbers = "12345"
    result = ""
    new_st = [str(i) for i in st]
    for i in new_st :
        if i in numbers :
            result += dict[i]
        else :
            result += i



#Complete the method which returns the number which is most frequent in the given input array. If there is a tie for most frequent number, return the largest number among them

def highest_rank(arr):
    res = []
    check = sorted([arr.count(i) for i in arr]) #list of sorted counts of each number
    new = [int(i) for i in arr if arr.count(i) == check[-1]] #returns an array of all the highest counting integers
    return max(new)

    return result        

#Given a positive integer of up to 16 digits, return true if it is a valid credit card number, and false if it is not.

def validate(n):
    num = [int(i) for i in str(n)]
    res = []
    updated_res = []
    for i in num :
        if i in num[-2::-2] :
            res.append(i*2)
        else :
            res.append(i)
    new = [int(i-9) if i > 9 else int(i) for i in res]#new_list = [expression_if_true if condition else expression_if_false for item in iterable]
    return sum(new) % 10 == 0



#Take a Number And Sum Its Digits Raised To The Consecutive Powers And ....Â¡Eureka!!


import math
def sum_dig_pow(a, b):
    res = []
    for i, c in enumerate(range(a, b + 1)):
        num_str = str(c)
        digit_sum = sum([int(x)**(i + 1) for i, x in enumerate(num_str)])
        if digit_sum == c:
            res.append(c)
    return res


#Write a method (or function, depending on the language) that converts a string to camelCase, that is, all words must have their first letter capitalized and spaces must be removed.


def camel_case(s):
    s = s.split()
    res = []
    for i in s :
        res.append(i.capitalize())
    return "".join(res)    


#If the left side is more heavy, return "Left"; if the right side is more heavy, return "Right"; if they are balanced, return "Balance"

def balance(left, right):
    left_count = 0
    right_count = 0
    for i in left :
        left_count = left.count("!") * 2
        left_count += left.count("?") * 3
        
    for i in right :
        right_count = right.count("!") * 2
        right_count += right.count("?") * 3 
    
    if left_count > right_count :
        return "Left"
    elif right_count > left_count :
        return "Right"
    else :
        return "Balance"
    
    
#Create a moreZeros function which will receive a string for input, and return an array (or null terminated string in C) containing only the characters from that string whose binary representation of its ASCII value consists of more zeros than ones.

def more_zeros(s):
    new =  [str(bin(ord(i))) for i in s]
    res = []
    for word in new :
        for i in word :
            if word.count("0") > word.count("1") : #need to iterate on each character
                res.append(word)
    final_res = sorted(set(res),key=new.index)
    
    answer = []
    for x in list(map(str,s)) :
        if bin(ord(x)) in final_res :
            answer.append(x)
    return sorted(set(answer),key=s.index)        
            


#Given an array of integers, find the one that appears an odd number of times.

def find_it(seq):
    check =  [seq.count(i) for i in seq if seq.count(i) % 2 != 0][0]
    return [int(i) for i in seq if  seq.count(i) == check][0]



