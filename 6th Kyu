#If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
#Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Additionally, if the number is negative, return 0 (for languages that do have them).
def solution(number) :
    arr = []
    result = []
    for i in range(0,number) :
        arr.append(i)
    for i in arr :
        if i % 3 == 0 :
            result.append(i)
        elif i % 5 == 0 :
            result.append(i)
        elif i < 0 :
            result
    return sum(set(result))        
    


#You probably know the "like" system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.
def likes(names) :
    result = ""
    if len(names) == 1 :
        result += names[0] + " likes this"
    elif len(names) ==2 :
        result +=  names[0] + " and " + names[1] + " like this"
    elif len(names) == 3 :
        result += names[0] +", " + names[1] + " and " + names[2] + " like this"
    elif len(names) >= 4 :
        result +=  names[0] + ", " + names[1] + " and " + str(len(names)-2) + " others like this"
    else :
        result += "no one like this"   
    return result

            
#Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

def create_phone_number(n):
    return "(%s%s%s) %s%s%s-%s%s%s%s" % (n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9])
    


#Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.

def count_bits(n):
    result = bin(int(n))
    return result.count("1")
    

#You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer 
def find_outlier(integers):
    even = []
    odd = []
    for i in integers :
        if i % 2 == 0 :
            even.append(i)
        else :
            odd.append(i)
    if len(even) > len(odd) :
        return odd[0] #remember we can use indexing to return 
    elif len(odd) > len(even) :
        return even[0]
    

Given an array of integers, find the one that appears an odd number of times.
def find_it(seq):
    result = []
    for i in seq :
        if seq.count(i) % 2 != 0 :
            result.append(i)
    return result[0]      



#Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string

def duplicate_count(text):
    result = []
    text = text.lower() #makes it case insensitive
    for i in text :
        if text.count(i) > 1 :
            result.append(i)
    return len(set(result))


def narcissistic( value ):
    result = []
    string_value = str(value)
    no_of_digits = len(str(value))
    arr_of_integers = [int(i) for i in string_value] #how to split a string into a list of integers
    for i in arr_of_integers :
        result.append(i**no_of_digits)
    if sum(result) == value :
        return True
    else :
        return False


##There is an array with some numbers. All numbers are equal except for one. Try to find it!

def find_uniq(arr):
    result = []
    for i in arr :
        if arr.count(i) == 1 :
            result.append(i)
    return result[0] 
     
#Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.It should remove all values from list a, which are present in list b keeping their order.
def array_diff(a, b):
    result = []
    for i in a :
        if i not in b :
            result.append(i)
    return result    



def parts_sums(ls):
    result = []
    for i in range(len(ls)) :
        result.append(ls[i:])
    result.append([])
    return list(map(sum,result))


#For example, encode("hello") would return "h2ll4". There is no need to worry about uppercase vowels in this kata.
def encode(st):
    dict = {"a":"1","e":"2","i":"3","o":"4","u":"5"}
    vowels = "aeiou"
    result = ""
    new_st = [str(i) for i in st]
    for i in new_st :
        if i == i.lower() and i in vowels :
            result += dict[i]
        else :
            result += i
    return result       

def decode(st) :
    dict = {"1":"a","2":"e","3":"i","4":"o","5":"u"}
    numbers = "12345"
    result = ""
    new_st = [str(i) for i in st]
    for i in new_st :
        if i in numbers :
            result += dict[i]
        else :
            result += i



#Complete the method which returns the number which is most frequent in the given input array. If there is a tie for most frequent number, return the largest number among them

def highest_rank(arr):
    res = []
    check = sorted([arr.count(i) for i in arr]) #list of sorted counts of each number
    new = [int(i) for i in arr if arr.count(i) == check[-1]] #returns an array of all the highest counting integers
    return max(new)

    return result        

#Given a positive integer of up to 16 digits, return true if it is a valid credit card number, and false if it is not.

def validate(n):
    num = [int(i) for i in str(n)]
    res = []
    updated_res = []
    for i in num :
        if i in num[-2::-2] :
            res.append(i*2)
        else :
            res.append(i)
    new = [int(i-9) if i > 9 else int(i) for i in res]#new_list = [expression_if_true if condition else expression_if_false for item in iterable]
    return sum(new) % 10 == 0



#Take a Number And Sum Its Digits Raised To The Consecutive Powers And ....Â¡Eureka!!


import math
def sum_dig_pow(a, b):
    res = []
    for i, c in enumerate(range(a, b + 1)):
        num_str = str(c)
        digit_sum = sum([int(x)**(i + 1) for i, x in enumerate(num_str)])
        if digit_sum == c:
            res.append(c)
    return res


#Write a method (or function, depending on the language) that converts a string to camelCase, that is, all words must have their first letter capitalized and spaces must be removed.


def camel_case(s):
    s = s.split()
    res = []
    for i in s :
        res.append(i.capitalize())
    return "".join(res)    


#If the left side is more heavy, return "Left"; if the right side is more heavy, return "Right"; if they are balanced, return "Balance"

def balance(left, right):
    left_count = 0
    right_count = 0
    for i in left :
        left_count = left.count("!") * 2
        left_count += left.count("?") * 3
        
    for i in right :
        right_count = right.count("!") * 2
        right_count += right.count("?") * 3 
    
    if left_count > right_count :
        return "Left"
    elif right_count > left_count :
        return "Right"
    else :
        return "Balance"
    
    
#Create a moreZeros function which will receive a string for input, and return an array (or null terminated string in C) containing only the characters from that string whose binary representation of its ASCII value consists of more zeros than ones.

def more_zeros(s):
    new =  [str(bin(ord(i))) for i in s]
    res = []
    for word in new :
        for i in word :
            if word.count("0") > word.count("1") : #need to iterate on each character
                res.append(word)
    final_res = sorted(set(res),key=new.index)
    
    answer = []
    for x in list(map(str,s)) :
        if bin(ord(x)) in final_res :
            answer.append(x)
    return sorted(set(answer),key=s.index)        
            


#Given an array of integers, find the one that appears an odd number of times.

def find_it(seq):
    check =  [seq.count(i) for i in seq if seq.count(i) % 2 != 0][0]
    return [int(i) for i in seq if  seq.count(i) == check][0]



#Reverse every other word in a given string, then return the string. Throw away any leading or trailing whitespace, while ensuring there is exactly one space between each word

def reverse_alternate(s):
    s = s.split()
    res = []
    for i,c in enumerate(s) :
        if i % 2 == 0 :
            res.append(c)
        else :
            res.append(c[::-1])
    return " ".join(res).strip()        
    


#Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.

def find_missing_letter(chars): 
    final_list = [ord(i) for i in chars]
    new = list(range(min(final_list),max(final_list)+1))  #total range
    res = []
    for i in new :
        if i not in final_list :
            res.append(i)
    return chr(res[0])



#he goal of this exercise is to convert a string to a new string where each character in the new string is "(" if that character appears only once in the original string, or ")" if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.

def duplicate_encode(word):
    word = word.lower()
    res = []
    for i in list(map(str,word)) :
        if word.count(i) > 1 :
            res.append(")")
        else :
            res.append("(")
    return "".join(res)        



#ou are given a string of numbers between 0-9. Find the average of these numbers and return it as a floored whole number (ie: no decimal places) written out as a string. Eg:"zero nine five two" -> "four"If the string is empty or includes a number greater than 9, return "n/a"

import re
def average_string(s):
    dict = {"zero":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9}
    s = s.split()
    for i in s :
        if i not in dict.keys() :
            return "n/a"
    
    new = [dict[i] for i in s]
    
    if not new :         #need to check if new is empty here before calculating the average to avoid zero divison error
        return "n/a"
    
    
    import math
    average = math.floor((sum(new) / len(new)))
    res = []
    
    
    if not s :
        return "n/a"

     
    else :
        for key,value in dict.items() : #iterate over dictionary
            if value == average :
                res.append(key)
        return "".join(res)        


#Given an integer n, find the maximal number you can obtain by deleting exactly one digit of the given number.

def delete_digit(n):
    n = str(n)
    res = []
    for i in range(len(n)) :
        new = n[:i] + n[i+1:] #includes everything up to the ith character + everything after the ith character therefore removing each character from the original string
        res.append(new)
    return max(list(map(int,res)))    
        

#Find the sum of the digits of all the numbers from 1 to N (both ends included).

def compute_sum(n):
    single_digits = [int(i) for i in range(1,n+1) if len(str(i)) == 1] #single_digits
    res = []
    for i in range(1,n+1) :
        if i not in single_digits :
            res.append(i) #list of double or more figure digits
            
            
    ans = []
    for num in res :
        for j in str(num) :
            ans.append(int(j))
    
    final = sum(single_digits) + sum(ans)
    return final
    
            
   #Complete the solution so that the function will break up camel casing, using a space between words.

def solution(s):
    new = [str(i) for i in s]
    res = []
    for i in range(len(new)-1) :
        if new[i].islower() and new[i+1].isupper() :
            word = new[i] + " "
            res.append(word)
        else :
            res.append(new[i])
            
    res.extend(new[-1])
    
            
    return "".join(res)     
                
        
def bingo(ticket,win):
    character_code = [list(i[0]) for i in ticket] #convert to a list of character codes
    num = [chr(i[1]) for i in ticket] #numbers list converted to int
    check = list(zip(character_code,num))
    
    res = [i[1] for i in check if i[1] in i[0]] #list comprehension result if there is a match
    
    if len(res) >= win :
        return "Winner!"
    else :
        return "Loser!"
    
    
#Create a function isAlt() that accepts a string as an argument and validates whether the vowels (a, e, i, o, u) and consonants are in alternate order.

def is_alt(s):
    vowels = "aeiou"
    res = []
    for i in range(len(s)-1):
        if s[i+1] in vowels and s[i] not in vowels :
            res.append(s[i])
        elif s[i+1] not in vowels and s[i] in vowels :
            res.append(s[i])
            
    res.extend(s[-1])
    return "".join(res) == s


#In this Kata, you will be given an array of strings and your task is to remove all consecutive duplicate letters from each string in the array.

def remove(s) :
    s = list(s)
    res = []
    for i in range(len(s)-1) :
        if s[i] != s[i+1] :
            res.append(s[i]) 
    res.extend(s[-1])
    return "".join(res)

#map this function to the array string below



def dup(arry):
    return list(map(remove,arry))   
           
#Given a string, remove any characters that are unique from the string.



def only_duplicates(string):
    string = list(string)
    new = [i for i in string if string.count(i) > 1]
    
    return "".join(new)                
            

#write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (Just like the name of this Kata).#Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.

def spin_words(sentence):
    new = sentence.split()

    if len(new) < 2 :
        if len(sentence) >= 5 :
            return sentence[::-1]
        else :
            return sentence
        
        
    else :
        res = []
        for word in new :
            if len(word) >= 5 :
                res.append(word[::-1])
            else :
                res.append(word)
                
        return " ".join(res)        
                

#In this kata you are required to, given a string, replace every letter with its position in the alphabet.

def alphabet_position(text):
    new = list(text)
    res = []
    for i in new :
        if i.isalpha() :
            res.append(str(ord(i.lower())-96))
            
    return " ".join(res)     
            
    
#Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation.

def is_pangram(s):
    new = list(s)
    res = []
    for i in new :
        if i.isalpha() and i not in " " :
            res.append(i.lower())
            
    return len(set(res)) == 26  
        
            
#The depth of an integer n is defined to be how many multiples of n it is necessary to compute before all 10 digits have appeared at least once in some multiple.

def compute_depth(n):
    count = 0 #number of multiples needed
    digits = list(range(10))
    digits_found = []
    
    
    while len(set(digits_found)) < len(digits) : #initialise while loop
        count += 1 #count increases by 1 each time
        ans = n * count
        for i in list(map(int,str(ans))) :
            digits_found.append(i)
    return count            
                    
                
  #Sort the given array of strings in alphabetical order, case insensitive. For example:

def sortme(words):
    return sorted(words,key = lambda x : x.lower()) #sorting based on the first character lowercase
      
    
#Complete the method/function so that it converts dash/underscore delimited words into camel casing.

def to_camel_case(text):
    if not text :
        return ""
    
    else :
    
        res = ""
        for i in text :
            if i.isalpha() :
                res += i 
            else :
                res += " " 

        new = res.split()

        if new[0][0].isupper() :
            upper = ""
            for i in new :
                upper += i.capitalize()
            return upper    

        elif not new[0][0].isupper() : #if first character is lowercase
            ans = [new[0]] 
            for i in new[1:] :
                ans.append(i.capitalize()) 
            return "".join(ans)    
            
    
            

#Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p

#we want to find a positive integer k, if it exists, such that the sum of the digits of n taken to the successive powers of p is equal to k * n.

def dig_pow(n, p):
    powers = list(range(p,p+len(str(n))))
    new = [int(i) for i in str(n)]
    res = []
    
    check = list(zip(new,powers))
    res = []
    for i in check :
        import math
        res.append(math.pow(i[0],i[1]))
        
    ans = int(sum(res)) #res is now the correct sum of the powers
    
    if ans % n == 0 :
        return int(ans / n)
    
    else :
        return -1
    
            
#your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.

def order(sentence):
    if not sentence :
        return ""
    
    else :
        sentence = sentence.split()
        return " ".join(sorted(sentence,key = lambda x : sorted(x)))
        

#A string is considered to be in title case if each word in the string is either (a) capitalised (that is, only the first letter of the word is in upper case) or (b) considered to be an exception and put entirely into lower case unless it is the first word, which is always capitalised.  

def title_case(title, minor_words=''):
    new = title.capitalize() #capitalizes the first word
    words = minor_words.split() #words that must be lower case#
    words_lower = [i.lower() for i in words]
    
    
    
    check = new.split() #eveything from the first word
    res = []
    for i in check :
        if i in new.split()[0] :
            res.append(i)
        else :    
            if i.lower() not in words_lower :
                res.append(i.capitalize())
            else :
                res.append(i.lower())
            
    return " ".join(res)
            
    
#Create a function that takes a string as a parameter and does the following, in this order:
#Replaces every letter with the letter following it in the alphabet (see note below). Makes any vowels capital. Makes any consonants lower case

def changer(s):
    check = list(range(ord("a"),ord("z")+1)) #lowercase check
    upper_check = list(range(65,91))
    res = []
    for i in list(s) :
        if i.isalpha() :
            if ord(i) == check[-1] :
                res.append(chr(check[0]))
            elif ord(i) == upper_check[-1] :
                res.append(chr(upper_check[0]))
            else :
                new_letter = chr(ord(i)+1) #new character
                res.append(new_letter)
                
        else :
            res.append(i) #appends everything which isn't a letter
                
    vowels = "aieuoAEIOU"
    ans = []
    for i in res :
        if i.isalpha() :
            if i in vowels :
                ans.append(i.upper())
            else :
                ans.append(i.lower())
                
        else :
            ans.append(i)
                
    return "".join(ans)            
            
     

#you have to write a function that receives a list, list size will always be at least 3 numbers. The missing term will never be the first or last one.

def find_missing(sequence):
    res = []
    for i in range(len(sequence)-2) :
        difference = abs(sequence[i+1]-sequence[i+2]) #skips the first index
        res.append(difference)
        
    # res[0] is the difference
    
   
    check = list(range(sequence[0],sequence[-1]+1,res[0])) #(start,stop,step) this gives the full list
    
    
    ans = 0
    for i in check :
        if i not in sequence :
            ans += i
            
    return ans

   

#Given a string of words, you need to find the highest scoring word.
#Each letter of a word scores points according to its position in the alphabet: a = 1, b = 2, c = 3 etc.


def score(word) :
    res = []
    for i in word :
        res.append(ord(i.lower())-96)
    return sum(res)    #function to create the scores

def high(x):
    new = x.split()
    res = []
    for i in new :
        check = list(map(score,i))
        res.append([i,sum(check)]) #gives a list of words alongside the sum of their ords
    final = sorted(res, key = lambda x : x[1])[-2:] #sort the list by the sum of the ords and then return the last two words
    
    
    
    lyy = []
    for i in final :
        lyy.append(i[1])
    
    if lyy[0] - lyy[1] == 0 :
        return final[-2][0]
    
    else :
        return final[-1][0]
    
        
   ##Write a function mineLocation/MineLocation that accepts a 2D array, and returns the location of the mine. The mine is represented as the integer 1 in the 2D array. Areas in the 2D array that are not the mine will be represented as 0s.


def mineLocation(field):
    res = []
    
    for i in field :
        for num in i :
            if "1" in str(num) : 
                res.append(field.index(i)) #res stores the row index of the mine
        
    res = int(res[0])
    
    check = field[res].index(1) #stores column index of the mine which is 1
    
    return [res,check]
        
    
    #Round any given number to the closest 0.5 step

def solution(n) :
    check = str(n)
    result = check.split(".")
    
    new = "0"+"."+result[-1] #isolates the part after the decimal
    
    if float(new) < 0.25 :
        import math
        return math.floor(n)
    
    elif float(new) >= 0.25 and float(new) <= 0.5 :
        return float(f"{result[0]}.5")
    
    elif float(new) > 0.5 and float(new) < 0.75 :
        return float(f"{result[0]}.5")
    
    else :
        import math
        return math.ceil(n)
    
    

#he array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

def find_outlier(integers):
    odd = [i for i in integers if i % 2 == 0]
    even = [i for i in integers if i % 2 != 0]
    if len(odd) == 1 :
        return odd[0]
    
    else :
        return even[0]

#Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

def duplicate_count(text):
    text = str(text).lower()
    duplicates = [i for i in text if text.count(i) > 1]
    
    return len(set(duplicates))
    

                 


