#If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
#Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Additionally, if the number is negative, return 0 (for languages that do have them).
def solution(number) :
    arr = []
    result = []
    for i in range(0,number) :
        arr.append(i)
    for i in arr :
        if i % 3 == 0 :
            result.append(i)
        elif i % 5 == 0 :
            result.append(i)
        elif i < 0 :
            result
    return sum(set(result))        
    


#You probably know the "like" system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.
def likes(names) :
    result = ""
    if len(names) == 1 :
        result += names[0] + " likes this"
    elif len(names) ==2 :
        result +=  names[0] + " and " + names[1] + " like this"
    elif len(names) == 3 :
        result += names[0] +", " + names[1] + " and " + names[2] + " like this"
    elif len(names) >= 4 :
        result +=  names[0] + ", " + names[1] + " and " + str(len(names)-2) + " others like this"
    else :
        result += "no one like this"   
    return result

            
#Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

def create_phone_number(n):
    return "(%s%s%s) %s%s%s-%s%s%s%s" % (n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9])
    


#Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.

def count_bits(n):
    result = bin(int(n))
    return result.count("1")
    

#You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer 
def find_outlier(integers):
    even = []
    odd = []
    for i in integers :
        if i % 2 == 0 :
            even.append(i)
        else :
            odd.append(i)
    if len(even) > len(odd) :
        return odd[0] #remember we can use indexing to return 
    elif len(odd) > len(even) :
        return even[0]
    

Given an array of integers, find the one that appears an odd number of times.
def find_it(seq):
    result = []
    for i in seq :
        if seq.count(i) % 2 != 0 :
            result.append(i)
    return result[0]      



#Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string

def duplicate_count(text):
    result = []
    text = text.lower() #makes it case insensitive
    for i in text :
        if text.count(i) > 1 :
            result.append(i)
    return len(set(result))


def narcissistic( value ):
    result = []
    string_value = str(value)
    no_of_digits = len(str(value))
    arr_of_integers = [int(i) for i in string_value] #how to split a string into a list of integers
    for i in arr_of_integers :
        result.append(i**no_of_digits)
    if sum(result) == value :
        return True
    else :
        return False



     
