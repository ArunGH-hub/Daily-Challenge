#You will be given a string of student names. Sort them and return a list of names in descending order.
def lineup_students(string):
        sorted_list = string.split(" ")
        return sorted(sorted_list,key=len)[::-1]

        
#The string given to your function has had an "egg" inserted directly after each consonant. You need to return the string before it became eggcoded.
def unscramble_eggs(word):
    return word.replace('egg','')


#Write a function that takes a single string (word) as argument. The function must return an ordered list containing the indexes of all capital letters in the string.

def capitals(word) :
    arr=[]
    for i in word :
       if i.upper() == i :
            index = word.index(i.upper())
            arr.append(index)
    return arr


#Your job is to write a function, which takes three integers a, b, and c as arguments, and returns True if exactly two of of the three integers are positive numbers (greater than zero), and False - otherwise.        
def two_are_positive(a,b,c):
    arr = []
    if a > 0 :
        arr.append(a)
    if b > 0 :
        arr.append(b)
    if c > 0 :
        arr.append(c)
    return  True if len(arr) == 2 else False  
 

#function that calculates the volume of a cone
import math
def cup_volume(d1, d2, height):
    volume = 1/3 * math.pi * height * ((d1/2)**2 + (d2/2)**2 + d1/2 * d2/2) #formula for volume of a cone
    return volume


#You will be given a string (x) featuring a cat 'C' and a mouse 'm'. The rest of the string will be made up of '.'.
def cat_mouse(x):
    index1 = x.index("C")
    index2 = x.index("m")
    difference = abs(index1 - index2)
    if difference <= 4 :
        return "Caught!"
    else :
        return "Escaped!"
            

def high_and_low(numbers):
    split = numbers.split(" ")
    integer_list = [int(i) for i in split]
    return str(max(integer_list)) + " " + str(min(integer_list))

#In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.
    

def square_digits(num):
    result = ""
    string_num = str(num)
    for i in string_num:
        result += str(int(i)**2)
    return result   

#this is correct, using the sm function is easy here


#our job is to return the middle character of the word. If the word's length is odd, return the middle character. If the word's length is even, return the middle 2 characters.
        
def get_middle(s):
    odd_index = int(len(s) // 2)
    even_index = int(len(s) / 2) #remember to include the letter after too
    int_even = even_index + 1
    if len(s) % 2 != 0 :
        return s[odd_index]
    else :
        return s[even_index-1 :even_index+1]
    

#Groups of characters decided to make a battle. Help them to figure out which group is more powerful. Create a function that will accept 2 strings and return the one who's stronger.
def battle(x,y):
    dict = {"A":1, "B":2, "C":3,"D":4,"E":5,"F":6,"G":7,"H":8,"I":9,"J":10,"K":11,"L":12,"M":13,"N":14,"O":15,"P":16,"Q":17,"R":18,"S":19,"T":20,"U":21,"V":22,"W":23,"X":24,"Y":24,"Z":25}
    #list_x = ",".join(x) #converts to a list #DON'T NEED THIS STEP
    x_arr = []
    for i in x :
        result = dict[i]
        x_arr.append(result)
    
    y_arr = []
    for i in y :
        result = dict[i]
        y_arr.append(result)
    
    if sum(y_arr) > sum(x_arr) :
        return y
    elif sum(x_arr) > sum(y_arr) :
        return x
    else :
        return "Tie!"


def find_short(s):
    s = s.split() # splits the string into a list of individual words
    l = min(s, key = len) # finds the shortest string in the list
    return len(l) # returns shortest word length

#ALTERNATIVE CORRECT SOLUTION here., you can use key = len for min


#If a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours! Otherwise, you can be sure he's not...

def friend(x):
    result = []
    for i in x :
        if len(i) == 4 :
            result.append(i)
    return result            

#odd or even
def odd_or_even(arr):
    if arr == [] :
        return "even"
    elif sum(arr) % 2 == 0 :
        return "even"
    else :
        return "odd"



#Check to see if a string has the same amount of 'x's and 'o's

def xo(s):
    s = s.lower()
    x_count = s.count("x")
    o_count = s.count("o")
    if x_count == o_count :
        return True
    else :
        return False



def open_or_senior(data):
    arr1 = [] #age_list
    arr2 = [] #handicap list
    arr = []
    for i in data:
        if i[0] >= 55 and i[1] > 7 :
            arr.append("Senior") 
        else :
            arr.append("Open")
    return arr        
   
    
#Input will consist of a list of pairs. Each pair contains information for a single potential member. Information consists of an integer for the person's age and an integer for the person's handicap.

def printer_error(s):
    len(s) >= 1
    colours = ["a","b","c","d","e","f","g","h","i","j","k","l","m"]
    result = []
    for i in s :
        if i not in colours :
            result.append(i)
    return str(len(result)) + "/" + str(len(s))
             
            
#Sometimes there are problems: lack of colors, technical malfunction and a "bad" control string is produced e.g. aaaxbbbbyyhwawiwjjjwwm with letters not from a to m            

def nb_year(p0, percent, aug, p):
    p0 > 0
    p > 0
    result = 0
    while p0 < p :
        p0 += p0 * percent/100 + aug
        result += 1
    return result

#In a small town the population is p0 = 1000 at the beginning of a year. The population regularly increases by 2 percent per year and moreover 50 new inhabitants per year come to live in the town.


#You are given an odd-length array of integers, in which all of them are the same, except for one single number.
def stray(arr):
    result = 0
    for i in arr:
         if arr.count(i) == 1 :
                result += i
    return result  


#Mr. Scrooge has a sum of money 'P' that he wants to invest. Before he does, he wants to know how many years 'Y' this sum 'P' has to be kept in the bank in order for it to amount to a desired sum of money 'D'.

def calculate_years(P, interest, tax, desired):
    years = 0
    income_tax = P * interest * tax
    result = (P * interest+1) - income_tax
    while P < desired :
        P += result
        years += 1 
    return years

#The order of the numbers passed in could be any order. The array will always include at least 2 items. If there are two or more oldest age, then return both of them in array format
def two_oldest_ages(ages):
    return sorted(ages)[-2:]

#In this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on:make as few changes as possible.
#if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.

def solve(s) :
    upper_string = ""
    lower_string = ""
    for i in s :
        if i == i.upper() :
            upper_string += i.upper()
        elif i == i.lower() :
            lower_string += i.lower()
    
    if len(lower_string) >= len(upper_string) :
        return s.lower()
    else :
        return s.upper()
        
        
#Create a function that returns the sum of the two lowest positive numbers given an array of minimum 4 positive integers. No floats or non-positive integers will be passed.

def sum_two_smallest_numbers(numbers):
    for i in numbers:
        if i > 0 :
            return sum(sorted(numbers)[0:2])


def longest(a1, a2):
    result = ""
    for i in a1 :
        if i not in result :
            result += i
    for i in a2 :
        if i not in result :
            result += i
    sorted_string = "".join(sorted(result)) #how to sort a string
    return sorted_string
            
#return number of vowels in a given string
def get_count(sentence):
    result = []
    vowels = ["a","o","e","i","u"]
    for i in sentence :
        if i in vowels :
            result.append(i)
    return len(result)


#Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.
def drop_cap(words):
    normalised_word = words.split(" ")
    result = []
    for i in normalised_word :
        if len(i) > 2 :
            result.append(i[0].upper() + i[1:].lower())
        else :
            result.append(i)
    return " ".join(result)

#correct soltuion


def disemvowel(string_):
    res = ""
    vowels = ["a","e","i","o","u"]
    for i in string_ :
        if i.lower() not in vowels :
            res += i
    return res        

#remove vowels

#Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

def solution(text, ending):
    end_index = len(ending)
    if text[-end_index:] == ending :
        return True
    else :
        return False

#Write a function that returns both the minimum and maximum number of the given list/array.

def min_max(lst):
    result = []
    result.append(min(lst))
    result.append(max(lst))
    return result    

 you need to create a function that when provided with a triplet, returns the index of the numerical element that lies between the other two elements.

def gimme(triplet) :
    result = []
    new_trip = sorted(triplet)[1]
    if new_trip in triplet:
        result.append(triplet.index(new_trip))
    return result[0]
        

#Write a function that takes an array of strings as an argument and returns a sorted array containing the same strings, ordered from shortest to longest.
a = ["Telescopes", "Glasses", "Eyes", "Monocles"]

sorted(a,key=len)




#plement a function that adds two numbers together and returns their sum in binary. The conversion can be done before, or after the addition.
def add_binary(a,b):
    result = str(bin(a+b))
    return result[2:]


#iven an integer as input, can you round it to the next (meaning, "greater than or equal") multiple of 5?

def round_to_next5(n) :
    import math
    return math.ceil(n/5) * 5


#Your task is to write a function which calculates the value of a word based off the sum of the alphabet positions of its characters.

def words_to_marks(s):
    count = 0 
    for i in s :
        value_of_word = ord(str(i))-96
        count += value_of_word
    return count    


def alphabet_war(fight):
    left_side_dict = {"w":4, "p":3,"b":2,"s":1}
    right_side_dict = {"m":4,"q":3,"d":2,"z":1}
    left_res = 0
    right_res = 0
    for i in fight :
        if i in left_side_dict : 
            left_res += left_side_dict[i]
        if i in right_side_dict :
            right_res += right_side_dict[i]
    if left_res > right_res :
        return "Left side wins!"
    elif right_res > left_res :
        return "Right side wins!"
    else :
        return "Let's fight again!"
    
# Write a function that accepts fight string consists of only small letters and return who wins the fight. When the left side wins return Left side wins!, when the right side wins return Right side wins!, in other case return Let's fight again   
    
def even_numbers(arr,n):
    result = []
    even_list = [int(i) for i in arr if i % 2 == 0]
    return even_list[-n:]         


#Given an array of positive integers (the weights of the people), return a new array/tuple of two integers, where the first one is the total weight of team 1, and the second one is the total weight of team 2.

def row_weights(array):
    team_1 = sum(array[::2])
    team_2 = sum(array[1::2])
    res = [team_1, team_2]
    return res


#Return an array containing the numbers from 1 to N, where N is the parametered value. Replace certain values however if any of the following conditions are met:

def fizzbuzz(n):
    result = []
    new_list = [int(i) for i in range(1,n+1)] 
    for i in new_list :
        if  i % 3 == 0 and i % 5 == 0 :
            result.append("FizzBuzz")
        elif i % 3 == 0 :
            result.append("Fizz")
        elif i % 5 == 0 :
            result.append("Buzz")
        else :
            result.append(i)
    return result        
            
            
#Write a method that takes one argument as name and then greets that name, capitalized and ends with an exclamation point.

def greet(name): 
    name = name.lower()
    final_name = name.capitalize()
    return "Hello %s!" %final_name
            

#Given a string str, reverse it and omit all non-alphabetic characters.

def reverse_letter(string):
    new_str = [str(i) for i in string if i.isalpha() is True]
    return "".join(new_str)[::-1]


#Find the number with the most digits. If two numbers in the argument array have the same number of digits, return the first one in the array.

def find_longest(arr):
    lengths = [len(str(i)) for i in arr] 
    int_lengths = sorted([int(i) for i in lengths]) #convert the lengths to integer and sort the list
    new_arr = [int(i) for i in arr if len(str(i)) == int_lengths[-1]]
    return new_arr[0]


#Given a number, write a function to output its reverse digits. (e.g. given 123 the answer is 321). Numbers should preserve their sign; i.e. a negative number should still be negative when reversed.

def reverse_number(n):
    if n < 0 :
        n = abs(n)
        new_n = "".join([str(i) for i in str(n)])
        return - int(new_n[::-1])
    else :
        new_n = "".join([str(i) for i in str(n)])
        return int(new_n[::-1])
    
   
#Write a function that takes a positive integer n, sums all the cubed values from 1 to n (inclusive), and returns that sum.

def sum_cubes(n):
    new = [int(i)**3 for i in range(1,n+1)]
    return sum(new)


##Write a program to determine if a string contains only unique characters. Return true if it does and false otherwise.


def has_unique_chars(string):
    new = [str(i) for i in string]
    for i in new :
        i == i.lower()
        if new.count(i) > 1 :
            return False
        else :
            return True

 #Given an array/list of integers, find the Nth smallest element in the array.    

def nth_smallest(arr, pos):
    new_arr = sorted(arr)
    return new_arr[pos-1]


#Given an array/list [] of n integers , Separate The even numbers from the odds , or Separate the men from the boys

def men_from_boys(arr):
    odd_list = sorted(set([int(i) for i in arr if i % 2 != 0]),reverse=True) #edscending order
    even_list = sorted(set([int(i) for i in arr if i % 2 == 0])) #ascending order
    return even_list + odd_list
    

#Solve("*'&ABCDabcde12345") = [4,5,5,3]. the order is: uppercase letters, lowercase, numbers and special characters.

def solve(s):
    uppercase = len([str(i) for i in s if i == i.upper() and i.isalpha() is True]) 
    lowercase = len([str(i) for i in s if i == i.lower() and i.isalpha() is True])
    numbers = len([str(i) for i in s if i.isdigit() is True])
    special = len([str(i) for i in s if i.isalpha() is not True and i.isdigit() is not True])
    res = [uppercase,lowercase,numbers,special]
    return res



#An ordered sequence of numbers from 1 to N is given. One number might have deleted from it, then the remaining numbers were mixed. Find the number that was deleted.
def find_deleted_number(arr, mixed_arr):
    result = 0
    for i in arr : 
        if i not in mixed_arr : 
            result += i 
        else :
            result 
    return result       
                

#Complete the function that takes two numbers as input, num and nth and return the nth digit of num (counting from right to left).

def find_digit(num, nth):
    num = str(abs(num))
    if nth < 1 :
        return -1
    elif len(str(nth)) > len(num) :
        return 0
    elif int(str(nth)) > len(str(num)) :
        return 0
    else :
        return int(num[-nth])



#Given a string s. You have to return another string such that even-indexed and odd-indexed characters of s are grouped and groups are space-separated (see sample below)



def sort_my_string(s):
    even_result = []
    odd_result = []
    for i,c in enumerate(s) : #enumerate is useful because it iterates an item and returns both the index position and value
        if i % 2 == 0 :
            even_result.append(c)
        else :
            odd_result.append(c)
    return "%s %s" % ("".join(even_result),"".join(odd_result))       
        

#Create a function that returns a sorted list of (key, value) tuples (Javascript: arrays of 2 items).

The list must be sorted by the value and be sorted largest to smallest.

def sort_dict(d):
    result = []
    tuple_d = d.items()
    return sorted(tuple_d,key = lambda x : x[1],reverse=True) #sorts based on value need to use x[1]


#e want to generate a function that computes the series starting from 0 and ending until the given number.

def show_sequence(n):
    if n == 0 :
        return "0=0" 
    elif n < 0 :
        return "%s<0" % (str(n))
    else :
        return "+".join((map(str,range(n+1)))) + " = " + str(sum(list(range(n+1)))) 


#Given a string, turn each character into its ASCII character code and join them together to create a number - let's call this number total1:Then replace any incidence of the number 7 with the number 1, and call this number 'total2':

def calc(x) :
    total1 =  sum([int(ord(i)) for i in str(x)]) #string is iterable, not int
    total2 = sum([int(str(int(ord(i))).replace("7","1")) for i in str(x)]) #iterating back to int
    return total1 - total2


#Given an array/list [] of integers , Find the product of the k maximal numbers.
import math
def max_product(lst, n_largest_elements):
    sorted_list = sorted(lst)[-n_largest_elements:]
    return math.prod(sorted_list)


#Given a string and an array of integers representing indices, capitalize all letters at the given indices.

def capitalize(s, ind):
    result = []
    for i,c in enumerate(s) :
        if i in ind :
            result.append(c.upper())
        else :
            result.append(c)
    return "".join(result)  



#You are given a string of letters and an array of numbers. The numbers indicate positions of letters that must be removed, in order, starting from the beginning of the array.

def last_survivor(letters, coords): 
    new = list(map(str,letters))
    for i in coords :
        new.pop(i)
    return "".join(new)    
        
      
  #Capitalise all vowels

def swap(st):
    result = []
    for i in st :
        if i in "aeiou" :
            result.append(i.upper())
        else :
            result.append(i)
    return "".join(result)        
                  
        
# In this Kata, you will be given two strings a and b and your task will be to return the characters that are not common in the two strings.

def solve(a,b):
    res = []
    for i in a :
        if i not in b :
            res.append(i)
    for i in b :
        if i not in a :
            res.append(i)
    return "".join(res)


#Return a string suggesting how many glasses of water you should drink to not be hungover.

def hydrate(drink_string):
    new = drink_string.split()
    water = sum([int(i) for i in drink_string if str(i).isdigit()])
    if water == 1 :
        return "%s glass of water" % (water)
    elif water > 1 :
        return "%s glasses of water" % (water)
    

#Given two words and a letter, return a single word that's a combination of both words, merged at the point where the given letter first appears in each word. The returned word should have the beginning of the first wordand the ending of the second, with the dividing letter in the middle

def string_merge(string1, string2, letter):
    ind1 = string1.index(letter)
    ind2 = string2.index(letter)
    return string1[:ind1] + string2[ind2:]



##Write a function that takes a single string (word) as argument. The function must return an ordered list containing the indexes of all capital letters in the string.

def capitals(word) :
    return sorted([int(i) for i,c in enumerate(word) if c.isupper()])


#Find the difference between the sum of the squares of the first n natural numbers (1 <= n <= 100) and the square of their sum.

def difference_of_squares(n):
    sum_num_sq = sum([int(i) for i in range(1,n+1)])**2
    sum_sq_ints = sum([int(i)**2 for i in range(1,n+1)])
    return sum_num_sq - sum_sq_ints


Complete the solution so that it returns a formatted string. The return value should equal "Value is VALUE" where value is a 5 digit padded number.

def solution(value):
    if len(str(value)) == 1 :
        return "Value is 0000%s"% value
    elif len(str(value)) == 2 :
        return "Value is 000%s" % value
    elif len(str(value)) == 3 : 
        return "Value is 00%s" % value
    elif len(str(value)) == 4 :
        return "Value is 0%s" % value
    else :
        return "Value is %s" % value
    
    
  #Given an array of numbers (in string format), you must return a string. The numbers correspond to the letters of the alphabet in reverse order: a=26, z=1 etc. You should also account for '!', '?' and ' ' that are represented by '27', '28' and '29' respectively.

def switcher(arr):
    my_dict = {
    "29": " ",
    "28": "?",
    "27": "!",
    "26": "a",
    "25": "b",
    "24": "c",
    "23": "d",
    "22": "e",
    "21": "f",
    "20": "g",
    "19": "h",
    "18": "i",
    "17": "j",
    "16": "k",
    "15": "l",
    "14": "m",
    "13": "n",
    "12": "o",
    "11": "p",
    "10": "q",
    "9": "r",
    "8": "s",
    "7": "t",
    "6": "u",
    "5": "v",
    "4": "w",
    "3": "x",
    "2": "y",
    "1": "z"
}
    new = [my_dict[i] for i in arr]
    return "".join(new)  
    
    
#Write a function filterLucky/filter_lucky() that accepts a list of integers and filters the list to only include the elements that contain the digit 7.

def filter_lucky(lst):
    return [int(i) for i in lst if "7" in str(i)]


#Given an array/list [] of integers , Find The maximum difference between the successive elements in its sorted form.

def max_gap(numbers):
    res = []
    numbers = sorted(numbers)
    for i in range(len(numbers)-1) :
        diff = abs(numbers[i+1]-numbers[i])
        res.append(diff)
    return max(res)    


#In this exercise, a string is passed to a method and a new string has to be returned with the first character of each word in the string.

def make_string(s):
    s = s.split()
    res = []
    for i in s :
        res.append(i[0])
    return "".join(res)    
        

#At some point during the walk the boy encounters a house with number 0 written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.

def house_numbers_sum(inp):
    zero_index = inp.index(0)
    return sum(inp[0:zero_index])


#omplete the method which accepts an array of integers, and returns one of the following

def is_sorted_and_how(arr): 
    if arr == sorted(arr) :
        return "yes, ascending" 
    elif arr == sorted(arr,reverse= True) :
        return "yes, descending"
    else :
        return "no"



#Given a mixed array of number and string representations of integers, add up the non-string integers and subtract the total of the string integers.

def div_con(x):
    new_int = sum([int(i) for i in x if i == int(i)]) 
    new_str = sum([int(i) for i in x if i == str(i)])
    return new_int - new_str
    

#When given a string of space separated words, return the word with the longest length. If there are multiple words with the longest length, return the last instance of the word with the longest length.

def longest_word(s):
    s = s.split()
    max_len = max([len(i) for i in s])
    res = []
    for i in s :
        if len(i) == max_len :
            res.append(i)
    return "".join(res[-1])      


#Given 2 strings, a and b, return a string of the form: shorter+reverse(longer)+shorter.In other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.
def shorter_reverse_longer(a,b):
    if len(a) == len(b) :
        return str(b)+str(a)[::-1]+str(b)
    else :
        longer = max(a,b,key=len)
        shorter = min(a,b,key=len)
        return shorter+longer[::-1]+shorter


#our task is to write a function toLeetSpeak that converts a regular english sentence to Leetspeak.
#Consider only uppercase letters (no lowercase letters, no numbers) and spaces.

def to_leet_speak(str):
    res = []
    dict = {
  "A" : '@',
  "B" : '8',
  "C" : '(',
  "D" : 'D',
  "E" : '3',
  "F" : 'F',
  "G" : '6',
  "H" : '#',
  "I" : '!',
  "J" : 'J',
  "K" : 'K',
  "L" : '1',
  "M" : 'M',
  "N" : 'N',
  "O" : '0',
  "P" : 'P',
  "Q" : 'Q',
  "R" : 'R',
  "S" : '$',
  "T" : '7',
  "U" : 'U',
  "V" : 'V',
  "W" : 'W',
  "X" : 'X',
  "Y" : 'Y',
  "Z" : '2'
}
    for i in str :
        if i.isalpha() and i.upper() :
            res.append(dict[i])
        else :
            res.append(i)
    return "".join(res)        


#Given an array with exactly 5 strings "a", "b" or "c" (chars in Java, characters in Fortran), check if the array contains three and two of the same values.

def check_three_and_two(array):
    check = [3,2]
    res = []
    for i in array :
        if array.count(i) <= 3 :
            res.append(array.count(i))
    if sum(set(res)) == sum(check) :
        return True
    else :
        return False
  
                   
#Create a function that returns the smallest number of turns it takes to transform the lock from the current combination to the target combination. One turn is equivalent to rolling a number forwards or backwards by one.

def min_turns(current, target):
    digits = list(range(0,10))
    current_lock = [int(i) for i in str(current)]
    target_lock = [int(i) for i in str(target)]
    turns = 0
    for i in range(len(current_lock)) : #4 digit lock
        forward_difference = abs(current_lock[i] - target_lock[i])
        backward_difference = abs(10 - forward_difference)
        turns += (min(forward_difference,backward_difference))
    return turns    


#ach number corresponds to their alphabetical order letter (e.g. 1 = A. 2 = B, etc). Write a function where you will win the game if your numbers can spell "BINGO".

def bingo(array): 
    win = ["B","I","N","G","O"]
    res = []
    new = [chr(i+96).upper() for i in array]
    for i in win :
        if i in set(new) :
            res.append(i)
    if len(res) == 5 :
        return "WIN"
    else :
        return "LOSE"


#Mumbling
#This time no story, no theory. The examples below show you how to write function accum:

def accum(s):
    return "-".join([(str(c)*i).capitalize() for i,c in enumerate(s,start=1)])


#In this kata you will create a function that takes a list of non-negative integers and strings and returns a new list with the strings filtered out.

def filter_list(l):
    return [int(i) for i in l if type(i)==int]

#Given an array of integers, remove the smallest value. Do not mutate the original array/list. If there are multiple elements with the same value, remove the one with a lower index. If you get an empty array/list, return an empty array/list.

def remove_smallest(numbers):
    if numbers == [] :
        return []
    else :
        min_num = str(min(numbers)) #convert to str
        new = [str(i) for i in numbers]
        min_num_index = new.index(min_num) #picks the first indexed minimum
        new.pop(min_num_index) #removes the first indexed minimum
        return list(map(int,new))


#Using n as a parameter in the function pattern, where n>0, complete the codes to get the pattern (take the help of examples):



#Examples
#pattern(3) should return "1\n1*2\n1**3", e.g. the following:

def pattern(n):
    return "".join([str(c)+"\n1"+(i*"*") for i,c in enumerate(range(1,n),start=1)]) + str(n)


#An element is leader if it is greater than The Sum all the elements to its right side.
def array_leaders(numbers):
    res = []
    for i,c in enumerate(numbers) :
        if numbers[i] > sum(numbers[i+1:]) :
            res.append(c)
    return res


#In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.

def high_and_low(numbers):
    numbers = numbers.split()
    new = list(map(int,numbers))
    return f"{max(new)} {min(new)}"


#In this Kata the aim is to compare each pair of integers from 2 arrays, and return a new array of large numbers.

def get_larger_numbers(a, b):
    new = list(zip(a,b))
    res = []
    for i in new :
        res.append(max(i))
    return res    
        

#Determine if the poker hand is flush, meaning if the five cards are of the same suit.

def is_flush(cards):
    suites = ["H","S","D","C"]
    res = []
    for word in cards :
        res.append(word[-1])
    if len(set(res)) == 1 : #royal flush


#When given a string of space separated words, return the word with the longest length. If there are multiple words with the longest length, return the last instance of the word with the longest length.

def longest_word(string_of_words):
    new = string_of_words.split()
    res = []
    max_word = max([len(i) for i in new]) #max length word
    for i in new :
        if len(i) == max_word :
            res.append(i)
    return res[-1]        

        return True
    else :
        return False
        


#However, when a noun STARTS and ENDS with the same letter, she likes to repeat the noun twice and connect them together with the first and last letter, combined into one word (WITHOUT "The" in front)

def band_name_generator(name):
    if len(name) == 1 :
        return name.capitalize()
    elif name[0] == name[-1] :
        return f"{name[:-1].capitalize()}{name}"
    else :
        return f"The {name.capitalize()}"



#Write a function, nicknameGenerator that takes a string name as an argument and returns the first 3 or 4 letters as a nickname.

def nickname_generator(name):
    vowels = "aeiou"
    if len(name) < 4 :
        return "Error: Name too short"
    else :
        for i in name[2] :
            if i not in vowels :
                return name[:3]
            if i in vowels :
                return name[:4]
            
        
#Calculate the sum of each value in the array to the nth power. Then subtract the sum of the original array.

def modified_sum(a, n):
    import math
    new = [math.pow(int(i),n) for i in a]
    return int(sum(new) - sum(a))


#Given a 2D ( nested ) list ( array, vector, .. ) of size m * n, your task is to find the sum of the minimum values in each row.

def sum_of_minimums(arr) :
    return sum(list(map(min,arr)))

#Write a function that takes an array of unique integers and returns the minimum number of integers needed to make the values of the array consecutive from the lowest number to the highest number.

def consecutive(arr):
    if arr == [] :
        return 0
    elif len(arr) == 1 :
        return 0
    else :
        
        arr = sorted(arr)
        count = 0
        total_arr = list(range(arr[0],arr[-1]+1))
    
        for i in total_arr :
            if i not in arr :
                count += 1
        return count       


#In this kata you will be given a random string of letters and tasked with returning them as a string of comma-separated sequences sorted alphabetically, with each sequence starting with an uppercase character followed by n-1 lowercase characters, where n is the letter's alphabet position 1-26.

def alpha_seq(string):
    string = string.lower()
    new =  sorted([str(i)*(ord(i)-96) for i in string])
    res = []
    for i in new :
        res.append(i.capitalize())
    return ",".join(res)    
    

#t checks if the word2 differs from word1 by at most one character. is can include an extra char at the end or the beginning of either of words.

def mispelled(word1,word2):
    word2 = [str(i) for i in word2]
    word1 = [str(i) for i in word1]
    res = []
    for i in word2 :
        if i in word1 :
            res.append(i)
    if abs(len(word1) - len(res)) == 0 :
        return True
    elif abs(len(word1) - len(res)) == 1 :
        return True
    else :
        return False
        

#Your are given a string. You must replace any occurence of the sequence coverage by covfefe, however, if you don't find the word coverage in the string, you must add covfefe at the end of the string with a leading space.

def covfefe(s):
    if "coverage" in s :
        return s.replace("coverage","covfefe") 
    else :
        return f"{s} {'covfefe'}"



#capitalise the whole string (Jaden case strings)

def to_jaden_case(s):
    s = s.split()
    return " ".join([str(i).capitalize() for i in s])



#Complete the function to create backronyms. Transform the given string (without spaces) to a backronym, using the preloaded dictionary and return a string of words, separated with a single space (but no trailing spaces).

#preloaded variable: "dictionary"

def make_backronym(acronym):
    new = [str(i).upper() for i in acronym] 
    res = []
    for i in new :
        res.append(dictionary[i])


#Write a function that reverses the bits in an integer.For example, the number 417 is 110100001 in binary. Reversing the binary is 100001011 which is 267.

def reverse_bits(n):
    new = int(bin(n)[2:])
    return int(str(new)[::-1],2) #int function takes base 2 as an argument to convert from binary


    return " ".join(res)
    
#Given an integer n and two other values, build an array of size n filled with these two values alternating.

def alternate(n, first_value, second_value):
    res = []
    if n == 0 :
        return []
    else :
        while len(res) < n :
            res.append(first_value)
            res.append(second_value)
        return res[:n]
